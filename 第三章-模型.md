第三章 模型
-----------  

In this chapter, we will discuss the following topics:
本章，我们将讨论以下话题：

>The importance of models
>模型的重要性

>Class diagrams
>类图表

>Model structural patterns
>模型结构模式

>Model behavioral patterns
>模型行为模式

>Migrations
>迁移

## M比V和C都更大
In Django, models are classes that provide an object-oriented way of dealing with databases. Typically, each class refers to a database table and each attribute refers to a database column. You can make queries to these tables using an automatically generated API.
在Django中，模型是具有处理数据库的一种面向对象的方法的类。通常，每个类都引用一个数据库表，每个属性都引用一个数据库列。你可以使用自动生成的API查询这些表。

Models can be the base for many other components. Once you have a model, you can rapidly derive model admins, model forms, and all kinds of generic views. In each case, you would need to write a line of code or two, just so that it does not seem too magical.
模型是很多其他组件的基础。只要你有一个模型，你可以快速地推导模型admin，模型表单，以及所有类型的通用视图。在每个例子中，你都需要下一个行或是两行代码，这样可以让它看上去没有太多魔法。

Also, models are used in more places than you would expect. This is because Django can be run in several ways. Some of the entry points of Django are as follows:
模型也被用在更多超出你期望的地方。这书因为Django可以以多种方法运行。Django的一些切入点如下：

>The familiar web request-response flow
>熟悉web请求-响应流程

>Django interactive shell
>Django的交互式shell

>Management commands
>管理命令

>Test scripts
>测试脚本

>Asynchronous task queues such as Celery
>异步任务队列比如Celery

In almost all these cases, the model modules would get imported (as a part of django.setup()). Hence, it is best to keep your models free from any unnecessary dependencies or to import any other Django components such as views.
在多数的这些例子中，模型模块要导入（作为django.setup()的一部分）。因此，最好保证模型远离任何不必要的依赖，或者导入任何的其他Django组件，比如视图。

In short, designing your models properly is quite important. Now let's get started with the SuperBook model design.
简而言之，恰当地设计模型是很重要的事情。现在，让我们从SuperBook模型设计开始。

### 注释
**自带午餐便当**
Author's Note: The progress of the SuperBook project will appear in a box like this. You may skip the box but you will miss the insights, experiences, and drama of working in a web application project.
*作者注释：SuperBook项目的进度会以这样的一个盒子出现。你可以跳过这个盒子，但是在web应用项目中的情况下，你缺少的是领悟，经验 。

Steve's first week with his client, the SuperHero Intelligence and Monitoring or S.H.I.M. for short, was a mixed bag. The office was incredibly futuristic but getting anything done needed a hundred approvals and sign-offs.
史蒂夫和客户的第一周——超级英雄情报监控（简称为S.H.I.M）。简单来说，这是一个大杂烩。办公室是非常未来化的，但是不论做什么事情都需要上百个审核和签字。

Being the lead Django developer, Steve had finished setting up a mid-sized development server hosting four virtual machines over two days. The next morning, the machine itself had disappeared. A washing machine-sized robot nearby said that it had been taken to the forensic department due to unapproved software installations.
作为Django开发者的领队，史蒂夫已经配置好了中型的运行超过两天的4台虚拟机。第二天的一个早晨，机器自己不翼而飞了。一个附近的清洁机器人说，机器被法务部们给带走了，他们要对未经审核的软件安装做出处理。

The CTO, Hart was, however, of great help. He asked the machine to be returned in an hour with all the installations intact. He had also sent pre-approvals for the SuperBook project to avoid any such roadblocks in future.
然而，CTO哈特给予史蒂夫了极大的帮助。他要求机器在一个小时之内完好无损地给还回去。他还对SuperBook项目做出了提前审核以避免将来可能出现的任何阻碍。

Later that afternoon, Steve was having a brown-bag lunch with him. Dressed in a beige blazer and light blue jeans, Hart arrived well in time. Despite being taller than most people and having a clean-shaven head, he seemed cool and approachable. He asked if Steve had checked out the previous attempt to build a superhero database in the sixties.
那个下午的稍晚些时候，史蒂夫给他带了一个午餐便当。身着一件米色外套和浅蓝色牛仔裤的哈特如约而至。尽管高出周围人许多，有着清爽面庞的他依旧那么帅气，那么平易近人。他问史蒂夫他之前是否尝试过构建一个60年代的超级英雄数据库。

"Oh yes, the Sentinel project, right?" said Steve. "I did. The database seemed to be designed as an Entity-Attribute-Value model, something that I consider an anti-pattern. Perhaps they had very little idea about the attributes of a superhero those days." Hart almost winced at the last statement. In a slightly lowered voice, he said, "You are right, I didn't. Besides, they gave me only two days to design the whole thing. I believe there was literally a nuclear bomb ticking somewhere."
”嗯，对的，是哨兵项目么？“，史蒂夫说道。”是我设计的。数据库看上去被设计成了一个条目-属性-值形式的模式，有些地方我考虑用反模式。可能，这些天他们有一些超级英雄属性的小想法。哈特几乎等不到听完最后一句，他压低嗓门道：“没错。是我的错。另外，他们只给了我两天来设计整个架构。他们这是在要我老命啊！”  

Steve's mouth was wide open and his sandwich had frozen at its entrance. Hart smiled. "Certainly not my best work. Once it crossed about a billion entries, it took us days to run any kind of analysis on that damn database. SuperBook would zip through that in mere seconds, right?"
听了这些，史蒂夫的嘴巴张的大大的，三明治也卡在口中。哈特微笑着道：“当然了，我还没有尽全力来做这件事。只要它成长为100万美元的单子，我们就可以多花点时间在这该死的数据库上了。SuperBook用它就能分分钟完事的，小史你说呢？”  

Steve nodded weakly. He had never imagined that there would be around a billion superheroes in the first place.
史蒂夫微微点头称是。他从来没有想过在这么样的地方将会有上百万的超级英雄出现。


## 模型搜寻
Here is a first cut at identifying the models in SuperBook. Typical to an early attempt, we have represented only the essential models and their relationships in the form of a class diagram:
这是在SuperBook中确定模型的第一部分。通常对于一个早期试验，我们只表示了基本模型，以及在一个类表中的表单的基本关系：

图：
![2015-05-28 14 27 35](https://www.packtpub.com/graphics/9781783986644/graphics/6644_03_01.jpg)

Let's forget models for a moment and talk in terms of the objects we are modeling. Each user has a profile. A user can make several comments or several posts. A Like can be related to a single user/post combination.
让我们忘掉模型一会儿，来谈谈我们正在构建的对象的术语。每个用户都有一个账户。用户可以写多个回复或者多篇文章。**Like**可以同时关联到一个单独的用户或者文章。

Drawing a class diagram of your models like this is recommended. Some attributes might be missing at this stage but you can detail them later. Once the entire project is represented in the diagram, it makes separating the apps easier.
推荐你像这样画一个模型的类表。这个步骤的某些属性或许缺失了，不过你可以在之后补充细节。只要整个项目用图表表示出来，便可以轻松地分离app。  

Here are some tips to create this representation:
这是创建此表示的一些提示：  

>Boxes represent entities, which become models.
>盒子表示条目，它将成为模型。

>Nouns in your write-up typically end up as entities.
>名词通常作为条目的终止。

>Arrows are bi-directional and represent one of the three types of relationships in Django: one-to-one, one-to-many (implemented with Foreign Keys), and many-to-many.
>箭头是双向的，表示Django中三种关系类型其中的一种：一对一，一对多（通过外键实现），和多对多。

>The field denoting the one-to-many relationship is defined in the model on the Entity-relationship model (ER-model). In other words, the star is where the Foreign Key gets declared.
>字段表明在基于条目-关系模型（ER-modle）的模型中定义了一对多关系。换句来说，星号是声明外键的地方。  

The class diagram can be mapped into the following Django code (which will be spread across several apps):
类图表可以映射到下面的Django代码中（它将遍及多个app）：  

```python
    class Profile(models.Model):
        user = models.OnToOneField(User)

    class Post(models.Model):
        posted_by = models.ForeignKey(User)

    class Comment(models.Model):
        commented_by = models.ForeignKey(User)
        for_post = models.ForeignKey(Post)

    class Like(models.Model):
        liked_by = models.ForeignKey(User)
        post = models.ForeignKey(Post)
```

Later, we will not reference the User directly but use the more general settings.AUTH_USER_MODEL instead.
这之后，我们不会直接地引用*User*，而是使用更加普通的*settings.AUTH_USER_MODEL*来替代。  


### 分割model.py到多个文件
Like most components of Django, a large models.py file can be split up into multiple files within a package. A package is implemented as a directory, which can contain multiple files, one of which must be a specially named file called __init__.py.
就像多数的Django组件那样，一个大的model.py文件可以在一个包内分割为多个文件。**package**通过一个目录来实现，它包含多个文件，目录中的一个文件必须是一个称为`__init__.py`特殊文件。  

All definitions that can be exposed at package level must be defined in __init__.py with global scope. For example, if we split models.py into individual classes, in corresponding files inside models subdirectory such as postable.py, post.py, and comment.py, then the __init__.py package will look like:
所有可以在包级别中暴露的定义都必须在`__init__.py`里使用全局变量域定义。例如，如果我们分割model.py到独立的类，models子文件夹中的对应文件，比如，postable.py，post.py和comment.py, 之后`__init__.py`包会像这样：  

```python
    from postable import Postable
    from post import Post
    from commnet import Comment
```

Now you can import models.Post as before.
现在你可以像之前那样导入models.Post了。  

Any other code in the __init__.py package will be run when the package is imported. Hence, it is the ideal place for any package-level initialization code.
在`__init__.py`包中的任何其他代码都会在包运行时被导入。因此，它是一个任意级别包初始化代码的理想之地。  

## 结构模式
This section contains several design patterns that can help you design and structure your models.
本节包含多个帮助你设计和构建模型的设计模式。  

### 模式-规范化模型
**Problem**: By design, model instances have duplicated data that cause data inconsistencies.
**问题**：通过设计，模型实例的重复数据引起数据不一致。  

**Solution**: Break down your models into smaller models through normalization. Connect these models with logical relationships between them.
**解决方法**：通过规范化，分解模型到更小的模型。使用这些模型之间的逻辑关系来连接他们。  

### 问题细节
Imagine if someone designed our Post table (omitting certain columns) in the following way:
想象一下，如果某人用下面的方法设计Post表（省略部分列）：  


| 超级英雄的名字        | 消息          | 发布时间  |
| ------------- |:-------------:| -----:|
| Captain Temper      | 消息已经发布过了？ | 2012/07/07/07:15 |
| Professor English      | 应该用“Is”而不是“Has"      |   2012/07/07/07:17 |
| Captain Temper | 消息已经发布过了？      |  2012/07/07/07:18 |
| Capt. Temper | 消息已经发布过了？      |  2012/07/07/07:19 |

I hope you noticed the inconsistent superhero naming in the last row (and captain's
consistent lack of patience).
我希望你注意到了在最后一行的超级英雄名字和之前不一致（船长一如既往的缺乏耐心）。  

If we were to look at the first column, we are not sure which spelling is
correct—Captain Temper or Capt. Temper. This is the kind of data redundancy
we would like to eliminate through normalization.
如果我们看看第一列，我们也不确定哪一个拼写是正确的——`Captain Temper或者Capt.Temper`。这就是我们要通过规范化消除的一种数据冗余。  

### 详解
Before we take a look at the fully normalized solution, let's have a brief primer on
database normalization in the context of Django models.
在我们看下完整的规范方案，让我们用Django模型的上下文来个关于数据库规范化的简要说明。  

### 规范化的三个步骤
Normalization helps you efficiently store data. Once your models are fully normalized,
they will not have redundant data, and each model should contain data that is only
logically related to it.
规范化有助于你更有效地的存储数据库。只要模型完全地的规范化处理，他们就不会有冗余的数据，每个模型应该只包含逻辑上关联到自身的数据。  

To give a quick example, if we were to normalize the Post table so that we can
unambiguously refer to the superhero who posted that message, then we need to
isolate the user details in a separate table. Django already creates the user table
by default. So, you only need to refer to the ID of the user who posted the message
in the first column, as shown in the following table:
这里给出一个简单的例子，如果我们规范化了Post表，我们就可以不模棱两可地引用发布消息的超级英雄，然后我们需要用一个独立的表来隔离用户细节。默认，Django已经创建了用户表。因此，你只需要在第一列中引用发布消息的用户的ID，一如下表所示：  

|用户ID|消息    |发布时间   |
|-----|:------:|---------:|
| 12      | 消息已经发布过了？ | 2012/07/07/07:15 |
| 8      | 应该用“Is”而不是“Has"      |   2012/07/07/07:17 |
| 12 | 消息已经发布过了？      |  2012/07/07/07:18 |
| 12 | 消息已经发布过了？      |  2012/07/07/07:19 |

Now, it is not only clear that there were three messages posted by the same user
(with an arbitrary user ID), but we can also find that user's correct name by looking
up the user table.
现在，不仅仅相同用户发布三条消息的清楚在列，而且我们可以通过查询用户表找到用户的正确的名字。  

Generally, you will design your models to be in their fully normalized form and then
selectively denormalize them for performance reasons. In databases, Normal Forms
are a set of guidelines that can be applied to a table to ensure that it is normalized.
Commonly found normal forms are first, second, and third normal forms, although
they could go up to the fifth normal form.
通常来说，你会按照模型的完全规规范化表来设计模型，也会因为性能原因而有选择性地非规范化设计。在数据库中，**Normal Forms**是一组可以被应用于表，确保表被规范化的指南。一般我们建立第一，第二，第三规范表，尽管他们可以递增至第五规范表。  

In the next example, we will normalize a table and create the corresponding Django
models. Imagine a spreadsheet called 'Sightings' that lists the first time someone spots
a superhero using a power or superhuman ability. Each entry mentions the known
origins, super powers, and location of first sighting, including latitude and longitude.
这接下来的例子中，我们规范化一个表，创建对应的Django模型。想象下有个名字称做“Sightings”的表格，它列出了某人第一次发现超级英雄使用能力或者特异功能。每个条目都提到了已知的原始身份，超能力，和第一次发现的地点，包括维度和经度。  

| 名字       | 原始信息     | 能力 |第一次使用记录（维度，经度，国家，时间） |
| ----------| :-----------:|:----:|----------------------------------:|
|Blitz      | Alien        |Freeze Flight|+40.75, -73.99; USA; 2014/07/03 23:12
|Hexa       |Scientist      |Telekinesis Flight|+35.68, +139.73; Japan; 2010/02/17 20:15
|Traveller  |Billonaire     |Time travel    |+43.62, +1.45, France; 2010/11/10 08:20

上面的地理数据提取自http://www.golombek.com/locations.html.  

### 第一规范表（1NF）
To confirm to the first normal form, a table must have:
为了确认第一个规范表格，这张表必须含有：  

>No attribute (cell) with multiple values
>多个没有属性（cell）的值

>A primary key defined as a single column or a set of columns(composite key)
>一个主键作为单独一列或者一组列（合成键）

Let's try to convert our spreadsheet into a database table. Evidently,
our 'Power' column breaks the first rule.
让我们试着把表格转换为一个数据库表。明显地，我们的`Power`列破坏了第一个规则。  

The updated table here satisfies the first normal form. The primary key (marked with

a *) is a combination of 'Name' and 'Power', which should be unique for each row.
更新过的表满足第一规范表。主键（用一个`*`标记）是`Name`和`Power`的合并，对于每一排它都应该是唯一的。 

|Name*|Origin|Power*|Latitude   |Longtitude |Country|Time       |
|-----|:----:|:----:|:---------:|:---------:|------------------:|
Blitz |Alien |Freeze|+40.75170  |-73.99420|USA|2014/07/03 23:12|
Blitz|Alien|Flight|+40.75170|-73.99420|USA|2013/03/12 11:30|
Hexa|Scientist|Telekinesis|+35.68330|+139.73330|Japan|2010/02/17 20:15|
Hexa|Scientist|Filght|+35.68330|+139.73330|Japan|2010/02/19 20:30|
Traveller|Billionaire|Time tavel|+43.61670|+1.45000|France|2010/11/10 08:20|



### 第二规范表
The second normal form must satisfy all the conditions of the first normal form.
In addition, it must satisfy the condition that all non-primary key columns must be
dependent on the entire primary key.
第二规范表必须满足所有第一规范表的条件。此外，它必须满足所有非主键列都必须依赖于整个主键的条件。

In the previous table, notice that 'Origin' depends only on the superhero, that is,
'Name'. It doesn't matter which Power we are talking about. So, Origin is not entirely
dependent on the composite primary key—Name and Power.
在之前的表，我们注意到`Origin`只依赖于超级英雄，即，`Name`。不论我们谈论的是哪一个`Power`。因此，`Origin`不是完全地依赖于合成组件-`Name`和`Power`。  

Let's extract just the origin information into a separate table called 'Origins' as shown here:
这里，让我们只取出原始信息到一个独立的，称做`Origins`的表：  

|Name*|Origin|
|-----|-----:|
Blitz|Alien|
Hexa|Scientist|
Traveller|Billionaire|

Now our Sightings table updated to be compliant to the second normal form looks like this:
现在`Sightings`表更新为兼容第二规范表，它大概是这个样子：  

|Name*|Power*|Latitude   |Longtitude |Country|Time       |
|-----|:----:|:---------:|:---------:|------------------:|
Blitz |Freeze|+40.75170  |-73.99420|USA|2014/07/03 23:12|
Blitz||Flight|+40.75170|-73.99420|USA|2013/03/12 11:30|
Hexa|Telekinesis|+35.68330|+139.73330|Japan|2010/02/17 20:15|
Hexa|Filght|+35.68330|+139.73330|Japan|2010/02/19 20:30|
Traveller|Time tavel|+43.61670|+1.45000|France|2010/11/10 08:20|
  

### 第三规范表
In third normal form, the tables must satisfy the second normal form and should
additionally satisfy the condition that all non-primary key columns must be directly
dependent on the entire primary key and must be independent of each other.
在第三规范表中，表格必须满足第二规范表，而且应该额外满足所有的非主键列都直接依赖整个主键，而且这些非主键列都是互相独立的这个条件。  

Think about the Country column for a moment. Given the Latitude and Longitude,
you can easily derive the Country column. Even though the country where a
superpowers was sighted is dependent on the Name-Power composite primary
key it is only indirectly dependent on them.
考虑下`Country`类。给出`维度`和`经度`，你可以轻松地得出`Country`列。即使观测到超级英雄的地方依赖于`Name-Power`合成键，但是它只是间接地依赖他们。  

So, let's separate the location details into a separate Countries table as follows:
因此，我们把详细地址分离到一个独立的国家表格中：  

|Location ID|Latitude*|Longtitude*|Country|
|-----------|:-------:|:---------:|------:|
1|+40.75170|-73.99420|USA|
2|+35.68330|+139.73330|Japan|
3|+43.61670|+1.45000|France|

Now our Sightings table in its third normal form looks like this:
现在`Sightings`表格的第三规范表大抵如此：  

|User ID*|Power*|Location ID|Time|
---------|:----:|:---------:|---:|
2|Freeze|1|2014/0703 23:12
2|Flight|1|2013/03/12 11:30
4|Telekinesis|2|2010/02/17 20:15
4|Flight|2|2010/02/19 20:30
7|Time tavel|3|2010/11/10 08:20

As before, we have replaced the superhero's name with the corresponding User ID
that can be used to reference the user table.
如之前所做的那样，我们用对应的`User ID`替换了超级英雄的名字，这个用户ID用来引用用户表格。

### Django模型
We can now take a look at how these normalized tables can be represented as
Django models. Composite keys are not directly supported in Django. The solution
used here is to apply the surrogate keys and specify the unique_together property
in the Meta class:
现在我们可以看看这些规范化的表格可以用来表现Django模型。Django中并不直接支持合成键。这里用到的解决方案是应用代理键，以及在`Meta`类中指定`unique_together`属性：  

```python
    class Origin(models.Model):
        superhero = models.ForeignKey(settings.AUTH_USER_MODEL)
        origin = models.CharField(max_length=100)

    class Location(models.Model):
        latitude = models.FloatField()
        longtitude = models.FloatField()
        country = models.CharField(max_length=100)

        class Meta:
            unique_together = ("latitude", "longtitude")

    class Sighting(models.Model):
        superhero = models.ForeignKey(settings.AUTH_USER_MODEL)
        power = models.CharField(max_length=100)
        location = models.ForeignKey(Location)
        sighted_on = models.DateTimeField()

        class Meta:
            unique_together = ("superhero", "power")
```

### 性能和非规范化
Normalization can adversely affect performance. As the number of models increase,
the number of joins needed to answer a query also increase. For instance, to find
the number of superheroes with the Freeze capability in USA, you will need to join
four tables. Prior to normalization, any information can be found by querying a
single table.
规范化可能对性能有不利的影响。随着模型的增长，需要应答查询的连接数也随之增加。例如，要在美国发现具有冷冻能力的超级英雄的数量，你需要连接四个表格。先前的内容规范后，任何信息都可以通过查询一个单独的表格被找到。  

You should design your models to keep the data normalized. This will maintain
data integrity. However, if your site faces scalability issues, then you can selectively
derive data from those models to create denormalized data.
你应该设计模式以保持数据规范化。这可以维持数据的完整性。然而，如果你面临扩展性问题，你可以有选择性地从这些模型取得数据以生成非规范化的数据。  
  
## 提示
**最佳实践**
*Normalize while designing but denormalize while optimizing.*
*因设计而规范，又因优化而非规范*

For instance, if counting the sightings in a certain country is very common, then
add it as an additional field to the Location model. Now, you can include the other
queries using Django (object-relational mapping) ORM, unlike a cached value.
例如，在一个确定的国家中计算观测次数是非常普通的，然后将观测次数作为一个附加的字段到`Location`模型。现在，你可以使用Django ORM 继承其他的查询，而不是一个缓存的值。  

However, you need to update this count each time you add or remove a sighting.
You need to add this computation to the save method of Sighting, add a signal
handler, or even compute using an asynchronous job.
然而，你需要在每次添加或者移除观测时更新这个计数。你需要添加本次计算到*Singhting*的`save`方法，添加一个信号处理器，甚至使用一个异步任务去计算。  

If you have a complex query spanning several tables, such as a count of superpowers
by country, then you need to create a separate denormalized table. As before, we
need to update this denormalized table every time the data in your normalized
models changes.
如果你有一个跨越多个表的负责查询，比如国家的超能力计算，你需要创建一个独立的非规范表格。就像前面那样，我们需要在每一次规范化模型中的数据改变时更新这个非规范的表格。  

Denormalization is surprisingly common in large websites because it is tradeoff
between speed and space. Today, space is cheap but speed is crucial to user
experience. So, if your queries are taking too long to respond, then you might
want to consider it.
令人惊讶的是非规范化在大型的网站中是非常普遍的，因为它是速度和存储空间两者之间的折衷。今天的存储空间已经比较便宜了，然而速度也是用户体验中至关重要的一环。因此，如果你的查询耗时过于久的话，那么就需要考虑非规范化了。  

## 我们应该一直使用规范化吗？
Too much normalization is not necessarily a good thing. Sometimes, it can introduce
an unnecessary table that can complicate updates and lookups.
过多的规范化是是件不必要的事。有时候，它可以引入一个非必需的能够重复更新和查询的表格。  

For example, your User model might have several fields for their home address. Strictly
speaking, you can normalize these fields into an Address model. However, in many
cases, it would be unnecessary to introduce an additional table to the database.
例如，你的`User`模型或许有好多个家庭地址的字段，你可以规范这些字段到一个`Address`模型中。可是，多数情况下，把一个额外的表引进数据库是没有必要的。  

Rather than aiming for the most normalized design, carefully weigh each
opportunity to normalize and consider the tradeoffs before refactoring.
与其针对大多数的非规范化设计，不如在代码重构之前仔细地衡量每个非规范化的机会，对性能和速度上做出一个折衷的选择。

  
## 模式-模型mixins
**Problem**: Distinct models have the same fields and/or methods duplicated violating
the DRY principle.
**问题**：明显地模型含有重复的相同字段/或者方法，违反了DRY原则。  

**Solution**: Extract common fields and methods into various reusable model mixins.
**方案**：提取公共字段和方法到各种不同的可复用的模型mixins中。  

## 问题细节
While designing models, you might find certain common attributes or behaviors
shared across model classes. For example, a Post and Comment model needs to keep
track of its created date and modified date. Manually copy-pasting the fields and
their associated method is not a very DRY approach.
设计模型时，你或许某些公共属性或者行为跨模型类共享。例如，`Post`和`Comment`模型需要一直跟踪自己的`created`日期和`modified`日期。手动地复制-粘贴字段和它们所关联的方法十分不符合DRY原则。  

Since Django models are classes, object-oriented approaches such as composition
and inheritance are possible solutions. However, compositions (by having a
property that contains an instance of the shared class) will need an additional
level of indirection to access fields.
由于Django的模型是类，像合成以及继承这样的面向对象方法都是可以选择的解决方案。然而，合成（具有包含一个共享类实例的属性）需要一个额外的间接层访问字段。  

Inheritance can get tricky. We can use a common base class for Post and Comments.
However, there are three kinds of inheritance in Django: concrete, abstract,
and proxy.
继承是有技巧的。我们可以对`Post`和`Comment`使用一个公共基类。然而，在Django中有三种类型的继承：**concrete（具体）**, **abstract（抽象）**, 和**proxy（代理）**。  

Concrete inheritance works by deriving from the base class just like you normally
would in Python classes. However, in Django, this base class will be mapped into
a separate table. Each time you access base fields, an implicit join is needed. This
leads to horrible performance.
而具体继承的运行视派生基类而定，就像你在Python类中通常用到的那样。不过，在Django中，这个基类将被映射到一个独立的表中。每次你访问基本字段时，都需要一个明确的连接。这样做会带来非常糟糕的性能问题。  

Proxy inheritance can only add new behavior to the parent class. You cannot add
new fields. Hence, it is not very useful for this situation.
代理继承只能添加新的行为到父类。你不能够添加新字段。因此，这种情况下它的用处也不大。  

Finally, we are left with abstract inheritance.
最后，我们只有寄希望于抽象继承了。  

## 详解  
Abstract base classes are elegant solutions used to share data and behavior among
models. When you define an abstract class, it does not create any corresponding table
in the database. Instead, these fields are created in the derived non-abstract classes.
抽象基类是用于模型之间共享数据和行为的简洁方案。当你定义一个抽象类时，它在数据库中并没有创建任何与之对象的表。相反，这些字段是在派生出来的非抽象类中创建的。  

Accessing abstract base class fields doesn't need a JOIN statement. The resulting
tables are also self-contained with managed fields. Due to these advantages, most
Django projects use abstract base classes to implement common fields or methods.
访问抽象基类字段不需要`JOIN`语句。带有可管理字段的结果表格也是不解自明的。为了利用这些优点，大多数的Django项目都使用抽象基类实现公共字段或者方法。  

Limitations of abstract models are as follows:
抽象模型的局限在于：  

* They cannot have a Foreign Key or many-to-many field from another model
* 它们不能够拥有外键或者其他模型的多対多字段。  

* They cannot be instantiated or saved
* 它们不能够被实例化或者保存起来。  

* They cannot be directly used in a query since it doesn't have a manager
* 它们查询中不能够直接地使用，因为它没有管理器。  

Here is how the post and comment classes can be initially designed with an abstract
base class:
下面展示了post和comment类如何使用一个抽象基类进行初始设计：  

```python
class Postable(models.Model):
    created = models.DateTimeField(auto_now_add=True)
    modified = modified.DateTimeField(auto_now=True)
    message = models.TextField(max_length=500)

    class Meta:
        abstract = True


class Post(Postable):
    ...


class Comment(Postable):
        ...
```

To turn a model into an abstract base class, you will need to mention abstract =
True in its inner Meta class. Here, Postable is an abstract base class. However, it is
not very reusable.
要将一个模型转换到抽象基类，你需要在它的内部`Meta`类中写上`abstract = True`。这里的`Postable`是一个抽象基类。可是，它不是那么的可复用。  

In fact, if there was a class that had just the created and modified field, then
we can reuse that timestamp functionality in nearly any model needing a
timestamp. In such cases, we usually define a model mixin.
实际上，如果有一个类含有`created`和`modified`字段，我们在后面就可以在几乎任何需要时间戳的模型中重复使用这个时间戳功能。  

### 模型mixins
Model mixins are abstract classes that can be added as a parent class of a model.
Python supports multiple inheritances, unlike other languages such as Java.
Hence, you can list any number of parent classes for a model.
模型mixins是一个可以把抽象类当作父类来添加的模型。不像其他的语法，比如Java那样，Python支持多种继承。因此，你可以列出一个模型的任意数量的父类。  

Mixins ought to be orthogonal and easily composable. Drop in a mixin to the list
of base classes and they should work. In this regard, they are more similar in
behavior to composition rather than inheritance.
Mixins应该是互相垂直的而且易于组合的。把一个mixin放进基类的列表，这些mixin应该可以正常运行。这样看来，它们在行为上更类似于合成而非继承。  

Smaller mixins are better. Whenever a mixin becomes large and violates the Single
Responsibility Principle, consider refactoring it into smaller classes. Let a mixin do
one thing and do it well.
小一些mixin的会好很多。不论何时当一个mixin变得很大，而且又违反了独立响应原则，就要考虑把它重构到一个小一些的类中去。就让mixin一次做好一件事吧。  

In our previous example, the model mixin used to update the created and
modified time can be easily factored out, as shown in the following code:
在前面的例子中，用于更新`created`和`modified`的时间的模型mixin可以轻松地分解出来，一如下面代码所示：  

```python
class TimeStampedModel(models.Model):
    created = modified.TimeStampModel(auto_now_add=True)
    modified = modified.DateTimeField(auto_now=True)

    class Meta:
        abstract = True


class Postable(TimeStampedModel):
    message = models.TextField(max_length=500)
    ...

    class Meta:
        abstract = True


class Post(Postable):
    ...


class Comment(Postable):
    ...
```

We have two base classes now. However, the functionality is clearly separated.
The mixin can be separated into its own module and reused in other contexts.
我们现在有两个超类了。不过，功能之间显然都是独立的。mixin可以分离到自己的模块之内，或者在其他的上下文中被重复利用。  

## 模式-用户账户
**Problem**: Every website stores a different set of user profile details. However,
Django's built-in User model is meant for authentication details.
**问题**：每一个网站都存储一组不同的用户账户细节。然而，Django的内建`User`模型旨在针对认证细节。  

**Solution**: Create a user profile class with a one-to-one relation with the user model.
**方案**：用一对一关系的用户模型，创建一个用户账户类。  

## 问题细节
Out of the box, Django provides a pretty decent User model. You can use it when
you create a super user or log in to the admin interface. It has a few basic fields,
such as full name, username, and e-mail.
Django提供一个开箱即用的相当不错的**User**模型。你可以在创建超级用户或者登录amdin接口的时候用到它。它含有少量的基本字段，比如全名，用户名，和电子邮件。  

However, most real-world projects keep a lot more information about users, such
as their address, favorite movies, or their superpower abilities. From Django 1.5
onwards, the default User model can be extended or replaced. However, official
docs strongly recommend storing only authentication data even in a custom user
model (it belongs to the auth app, after all).
然而，大多数的现实世界项目都保留了很多关于用户的信息，比如他们的地址，喜欢的电影，或者它们的超能力。打Django1.5开始，默认的User模型就可以被扩展或者替换掉。不过，官方文档极力推荐只存储认证数据，即便是在定制的用户模型中也是如此（毕竟，用户模型也是所属于`auth`这个app的）。  

Certain projects need multiple types of users. For example, SuperBook can be used
by superheroes and non-superheroes. There might be common fields and some
distinctive fields based on the type of user.
某些项目是需要多种类型的用户的。例如，SuperBook可以被超级英雄和非超级英雄所使用。这里或许会有一些公共字段，以及基于用户类型的不同字段。  

## 详解
The officially recommended solution is to create a user profile model. It should have
a one-to-one relation with your user model. All the additional user information is
stored in this model:
官方推荐解决方案是创建一个用户账户模型。它应该和用户模型有一个一对一的关系。其余的全部用户信息都存储于该模型：  

```python
class Profile(models.Model):
    user = models.OnToOneField(settings.AUTH_USER_MODEL, primary_key=True)
```

It is recommended that you set the primary_key explicitly to True to prevent
concurrency issues in some database backends such as PostgreSQL. The rest of the
model can contain any other user details, such as birthdate, favorite color, and so on.
这里建议你明确的将`primary_key`赋值为`True`，以阻止类似PostgreSQL这样的数据库后端中的并发问题。剩下的模型可以包含其他的任何用户详情，比如生日，喜好色彩，等等。  

While designing the profile model, it is recommended that all the profile detail fields
must be nullable or contain default values. Intuitively, we can understand that a user
cannot fill out all his profile details while signing up. Additionally, we will ensure
that the signal handler also doesn't pass any initial parameters while creating the
profile instance.
设计账户模型之时，建议所有的账户详情字段都必须是非空的，或者含有一个默认值。凭直觉我们就知道用户在注册时是不可能填写完所有的账户细节的。此外，我们也要确保创建账户实例时，信号处理器没有传递任何初始参数。  

### 信号
Ideally, every time a user model instance is created, a corresponding user profile
instance must be created as well. This is usually done using signals.
理论上，每一次用户模型实例的生成，其对应的用户账户实例也必须创建好。这个操作通常使用信号来完成。

For example, we can listen for the post_save signal from the user model using
the following signal handler:
例如，我们可以使用下面的信号处理器侦听用户模型的`post_save`信号：  

```python
# signals.py
from django.db.models.signals import post_save
from django.dispatch import receiver
from django.conf import settings
from . import models


@receiver(post_save, sender=settings.AUTH_USER_MODEL)
def create_profile_handler(sender, instance, created, **kwargs):
    if not created:
        return
    # 仅在created是最新时才创建账户对象
    profile = models.Profile(user=instance)
    profile.save()
```

Note that the profile model has passed no additional initial parameters except for the
user instance.
注意账户模型除了用户实例之外并没有传递额外初始的参数。  

Previously, there was no specific place for initializing the signal code. Typically, they
were imported or implemented in models.py (which was unreliable). However, with
app-loading refactor in Django 1.7, the application initialization code location is well
defined.
前面的代码中，初始化信号代码并没有放到特定的场所。通常，它们在`models.py`中（这样做是不可靠的）导入或者执行。不过，随着Django 1.7的应用载入的重构，应用初始化代码位置的问题也很好的解决了。  

First, create a __init__.py package for your application to mention your app's
ProfileConfig:
首先，为你的应用创建一个`__init__.py`包以引用应用的`ProfileConfig`:  

```python
    default_app_config = "profile.apps.ProfileConfig"
```

Next, subclass the ProfileConfig method in app.py and set up the signal in the
ready method:
接下来是`app.py`中的子类`ProfileConfig`方法，可使用`ready`方法配置信号：  

```python
    # app.py
    from django.apps import AppConfig


    class ProfileConfig(AppConfig):
        name = "profiles"
        verbose_name = "User Profiles"


        def ready(self):
            from . import signals
```

With your signals set up, accessing user.profile should return a Profile object to
all users, even the newly created ones.
随着信号的配置，对所有的用户来说，访问`user.profile`应该都返回一个`Profile`对象，即使是最新创建的用户也是如此。  

### Admin
Now, a user's details will be in two different places within the admin: the
authentication details in the usual user admin page and the same user's additional
profile details in a separate profile admin page. This gets very cumbersome.
现在，用户的详情存在admin内的两个不同地方：普通用户admin页面中的认证细节，同一个用户的额外账户细节放到了一个独立账户的admin页面， 这样做显得非常麻烦。  

For convenience, the profile admin can be made inline to the default user admin by
defining a custom UserAdmin as follows:
如下，为了操作方便，账户admin可以通过定义一个自定义的`UserAdmin`嵌入到默认的用户admin中：  

```python
# admin.py
from django.contrib import admin
from .models import Profile
from django.contrib.auth.models import User


class UserProfileInline(admin.StackedInline):
    model = Profile


class UserAdmin(admin.UserAdmin):
    inlines = [UserProfileInline]


admin.site.unregister(User)
admin.site.register(User, UserAdmin)
```
  
### 多个账户类型
Assume that you need several kinds of user profiles in your application. There
needs to be a field to track which type of profile the user has. The profile data itself
needs to be stored in separate models or a unified model.
假设在应用中你需要几种类型的用户账户。这里需要有一个字段去跟踪用户使用的是哪一种账户类型。账户数据本身需要存储在独立的模型中，或者存储在一个统一的模型中。  

An aggregate profile approach is recommended since it gives the flexibility to
change the profile types without loss of profile details and minimizes complexity.
In this approach, the profile model contains a superset of all profile fields from all
profile types.
建议使用聚合账户的办法，因为它能够改变账户类型而不丢失账户细节，兼具灵活性，最小化复杂性。此办法中，账户模型包含一个所有账户类型的字段超集。  

For example, SuperBook will need a SuperHero type profile and an Ordinary
(non-superhero) profile. It can be implemented using a single unified profile
model as follows:
例如，SuperBook会需要一个`SuperHero`类型账户，和一个`Ordinary`（非超集英雄）账户。它可以用一个独立的统一账户模型实现：  

```python
class BaseProfile(models.Model):
    USER_TYPES = (
        (0, 'Ordinary'),
        (1, 'SuperHero'),
    )

    user = models.OnToOneField(settings.AUTH_USER_MODEL, primary_key=True)
    user_type = models.IntegerField(max_length=1, null=True,    choices=USER_TYPES)
    bio = models.CharField(max_length=200, blank=True, null=True)

    def __str__(self):
        return "{}:{:.20}".format(self.user, self.bio or "")

    class Meta:
        abstract = True


class SuperHeroProfile(models.Model):
    origin = models.CharField(max_length=100, blank=True, null=True)

    class Meta:
        abstract = True


class OrdinaryProfile(models.Model):
    address = models.CharField(max_length=200, blank=True, null=True)

    class Meta:
        abstract = True


class Profile(SuperHeroProfile, OrdinaryProfile, BaseProfile):
    pass
```

We grouped the profile details into several abstract base classes to separate concerns.
The BaseProfile class contains all the common profile details irrespective of the
user type. It also has a user_type field that keeps track of the user's active profile.
我们把账户细节组织到多个抽象基类再到独立的关系中。`BaseProfile`类包含所有的不关心用户类型的公共账户细节。它也有一个`user_type`字段，它持续追踪用户的激活账户。  

The SuperHeroProfile class and OrdinaryProfile class contain the profile details
specific to superhero and non-hero users respectively. Finally, the profile class
derives from all these base classes to create a superset of profile details.
`SuperHeroProfile`类和`OrdinaryProfile`类分别包含所有到超级英雄和非超级英雄特定账户细节。最后，所有这些基类的`profile`类创建了一个账户细节的超集。  

Some details to take care of while using this approach are as follows:
使用该方法时要主要的一些细节：  

* All profile fields that belong to the class or its abstract bases classes
must be nullable or with defaults.
* 所有属于类的字段或者它抽象基类都必须是非空的，或者有一个默认值。  

* This approach might consume more database space per user but gives
immense flexibility.
* 此方法或许会因为每个用户而消耗掉更多的数据库，但是却带来极大的灵活性。  

* The active and inactive fields for a profile type need to be managed
outside the model. Say, a form to edit the profile must show the
appropriate fields based on the currently active user type.
* 账户类型的激活和非激活字段都必须在模型外部是可管理的。  
说到，编辑账户的表必须显示合乎目前激活用户类型的字段。  

## 模式-服务模式  
**Problem**: Models can get large and unmanageable. Testing and maintenance
get harder as a model does more than one thing.
**问题**：模型会变得庞大而且不可管控。当一个模型不止实现一个功能时，测试和维护也会变得困难。  

**Solution**: Refactor out a set of related methods into a specialized Service object.
**解决方法**：重构出一组相关方法到一个专用的`Service`对象中。  

### 问题细节
Fat models, thin views is an adage commonly told to Django beginners. Ideally,
your views should not contain anything other than presentation logic.
富模型，瘦视图是一个通常要告诉Django新手的格言。理论上，你的视图不应该包含任何其他表现逻辑。  

However, over time pieces of code that cannot be placed anywhere else tend to go
into models. Soon, models become a dump yard for the code.
可是，随着时间的推移，代码段不能够放在任意地点，除非你打算将它们放进模型中。很快，模型会变成一个代码的垃圾场。  

Some of the tell-tale signs that your model can use a Service object are as follows:
下面是模型可以使用`Service`对象的征兆：  

1. Interactions with external services, for example, checking whether the
user is eligible to get a SuperHero profile with a web service.
1. 与扩展能服务交互，例如web服务中，检查一个用户具有资格。  

Helper tasks that do not deal with the database, for example, generating
a short URL or random captcha for a user.
2. 辅助任务不会处理数据库，例如，生成一个短链接，或者针对用户的验证码。  

Involves a short-lived object without a database state, for example,
creating a JSON response for an AJAX call.
3. 牵涉到一个短命的对象时不会存在数据库状态记录，烈日，创建一个AJAX调用的JSON响应。  

Long-running tasks involving multiple instances such as Celery tasks.
4. 对于长时间运行的任务设计到了多实例，比如Celery任务。  

Models in Django follow the Active Record pattern. Ideally, they encapsulate both
application logic and database access. However, keep the application logic minimal.
Django中的模型遵循着激活记录模式。理论上，它们同时封装应用罗即数据库访问。不过，要记得保持应用逻辑最小化。  

While testing, if we find ourselves unnecessarily mocking the database even while
not using it, then we need to consider breaking up the model class. A Service object
is recommended in such situations.
在测试时，如果我们发现没有对数据库建模的必要，甚至不会用到数据库，那么我们需要考虑把分解模型类。建议这种场合下使用`Service`对象。  


### 详解  
Service objects are plain old Python objects (POPOs) that encapsulate a 'service'
or interactions with a system. They are usually kept in a separate file named
services.py or utils.py.
服务对象是封装一个`服务`或者和系统狡猾的普通而老旧的Python对象（POPOs）。它们通常保存在一个独立的称为`service.py`或者`utils.py`的文件。  

For example, checking a web service is sometimes dumped into a model method
as follows:
例如，像下面这样，检查一个web服务是否作为一个模型方法：  

```python
class Profile(models.Model):
    ...

    def is_superhero(self):
        url = "http://api.herocheck.com/?q={0}".format(
            self.user.username
            )
        return webclient.get(url)
```

This method can be refactored to use a service object as follows:
该方法可以使用一个服务对象来重构：  

```python
from .services import SuperHeroWebAPI

def is_superhero(self):
    return SuperHeroWebAPI.is_superhero(self.user.username)
```

The service object can be now defined in services.py as follows:
现在服务对象可以定义在`services.py`中了：  

```python
API_URL = "http://api.herocheck.com/?q={0}"

class SuperHeroWebAPI:
    ...

    @staticmehtod
    def is_hero(username):
        url = API_URL.format(username)
        return webclient.get(url)
```
In most cases, methods of a Service object are stateless, that is, they perform the
action solely based on the function arguments without using any class properties.
Hence, it is better to explicitly mark them as static methods (as we have done
for is_hero).
多数情况下，`Service`对象的方法是无状态的，即，它们基于函数参数不使用任何的类属性来独立执行动作。因此，最好明确地把它们标记为静态方法（就像我们对`is_hero`所做的那样）。  

Consider refactoring your business logic or domain logic out of models into service
objects. This way, you can use them outside your Django application as well.
可以考虑把业务逻辑和域名逻辑从模型迁移到服务对象中去。这样，你可以在Django应用的外部很好使用它们。

Imagine there is a business reason to blacklist certain users from becoming
superhero types based on their username. Our service object can be easily
modified to support this:
想象一下，由于业务的原因，要依据某些用户的名字把这些要成为超级英雄的用户加进黑名单。我们的服务对象稍微改动以下就可以支持这个功能：  

```python
class SuperHeroWebAPI:
    ...

    @staticmethod
    def is_hero(username):
        blacklist = set(["syndrome", "kcka$$", "superfake"])
        ulr = API_URL.format(username)
        return username not in blacklist and webclient.get(url)
```

Ideally, service objects are self-contained. This makes them easy to test without
mocking, say, the database. They can be also easily reused.
理论上，服务对象自包含的。这使它们易于测试而不用建模——即数据库，同时它们也轻松地重复使用。  

In Django, time-consuming services are executed asynchronously using task queues
such as Celery. Typically, the Service Object actions are run as Celery tasks. Such
tasks can be run periodically or after a delay.
Django中，耗时服务以Celery这样的异步任务队列方式执行。通常，`Service`对象以Celery任务的方式执行操作。这样的任务可以周期性地运行或者延迟运行。  

## 检索模式
This section contains design patterns that deal with accessing model properties or
performing queries on them.
本节包含处理模型特性的访问，或者对模型执行查询的设计模式。  

### 模式-属性字段
**Problem**: Models have attributes that are implemented as methods. However, these
attributes should not be persisted to the database.
**问题**：模型的属性以方法实现。可是，这些属性不应该保存到数据库。  

**Solution**: Use the property decorator on such methods.
**解决方案**：对这样的方法使用特性装饰器。  

### 问题详情
Model fields store per-instance attributes, such as first name, last name, birthday,
and so on. They are also stored in the database. However, we also need to access
some derived attributes, such as full name or age.
模型字段存储每个实例的属性，比如名，和姓，生日，等等。它们存储于数据库之中。可是，我们也需要访问某些派生的属性，比如一个完整的名字和年龄。  

They can be easily calculated from the database fields, hence need not be stored
separately. In some cases, they can just be a conditional check such as eligibility
for offers based on age, membership points, and active status.
它们可以轻易地计算数据库字段，因此它们不需要单独地存储。在某些情况下，它们可以成为一个检查给出的年龄，会员积分，和激活状态是否合格的条件语句。  

A straightforward way to implement this is to define functions, such as get_age
similar to the following:
简洁明了的实现这个方法是定义类似下面的`get_age`来实现：  

```python
class BaseProfile(models.Model):
    birthdate = models.DateField()
    #...

    def get_age(self):
        today = datetime.date.today()
        return (today.year - self.birthdate.year) - int(
            (today.month, today.day) < (self.birthdate.month, self.birthdate.day)
            )
```

Calling profile.get_age() would return the user's age by calculating the
difference in the years adjusted by one based on the month and date.
调用`profile.get_age()`便会通过计算调整过的月和日期所属的那个年份的不同来返回用户的年龄。  

However, it is much more readable (and Pythonic) to call it profile.age.
不过，调用`profile.age`更具可读性（和Python范）。  

### 详解  
Python classes can treat a function as an attribute using the property decorator.
Django models can use it as well. In the previous example, replace the function
definition line with:
Python类可以使用`property`装饰器把函数当作一个属性来使用。这样，Django模型也可以较好地利用它。替换前面那个例子中的函数：  

```python
    @property
    def age(self):
```

Now, we can access the user's age with profile.age. Notice that the function's
name is shortened as well.
现在我们可以用`profile.age`来访问用户的年龄。注意，函数的名称要尽可能的短。  

An important shortcoming of a property is that it is invisible to the ORM, just like
model methods are. You cannot use it in a QuerySet object. For example, this will
not work, Profile.objects.exclude(age__lt=18).
就像模型的方法那样，属性的一个重大缺陷是它对于ORM来说是不可访问的。你不能够在`Queryset`对象中使用它。例如，这么做是无效的，`Profile.objects.exlude(age__lt=18)。  

It might also be a good idea to define a property to hide the details of internal
classes. This is formally known as the Law of Demeter. Simply put, the law states
that you should only access your own direct members or "use only one dot".
它也是一个定义一个属性来隐藏类内部细节的好主意。这也正式地称做*得墨忒耳定律*。简单地说，定律声明你应该只访问自己的直属成员或者“仅使用一个点号”。  

For example, rather than accessing profile.birthdate.year, it is better to define
a profile.birthyear property. It helps you hide the underlying structure of the
birthdate field this way.
例如，最好是定义一个`profile.birthyear`属性，而不是访问`profile.birthdate.year`。这样，它有助于你隐藏`birthdate`字段的内在结构。  

>## 提示
>**最佳实践**  
>*Follow the law of Demeter, and use only one dot when accessing a property.
>*遵循得墨忒耳定律，并且访问属性时只使用点号*  

An undesirable side effect of this law is that it leads to the creation of several
wrapper properties in the model. This could bloat up models and make them
hard to maintain. Use the law to improve your model's API and reduce coupling
wherever it makes sense.
该定律的一个不良反应是它导致在模型中有多个包装器属性被创建。这使模型膨胀并让它们变得难以维护。利用定律来改进你的模型API，减少模型间的耦合，在任何地方都是可行的。  

### 缓存特性
Each time we call a property, we are recalculating a function. If it is an expensive
calculation, we might want to cache the result. This way, the next time the property
is accessed, the cached value is returned.
每次我们调用一个属性时，就要重新计算函数。如果计算的代价很大，我们就想到了缓存结果。因此，下次访问属性，我们就拿到了缓存的结果。  

```python
from django.utils.function import cached_property
    #...
    @cached_property
    def full_name(self):
        # 代价高昂的操作，比如，外部服务调用
        return "{0} {1}".format(self.firstname, self.lastname)
```

The cached value will be saved as a part of the Python instance. As long as the
instance exists, the same value will be returned.
缓存的值会作为Python实例的一部分而保存。只要实例一直存在，就会得到同样的返回值。  

As a failsafe mechanism, you might want to force the execution of the expensive
operation to ensure that stale values are not returned. In such cases, set a keyword
argument such as cached=False to prevent returning the cached value.
就保护性机制来说，你或许想要强制执行代价高昂的操作以确保过期的值不会返回。这样，设置一个`cached=False`这样的关键字参数以阻止返回缓存的值。  

## 模式-定制模型管理器
**Problem**: Certain queries on models are defined and accessed repeatedly
throughout the code violating the DRY principle.
**问题**：某些模型的定义的查询被重复地访问，整个代码也就违反了DRY原则。  

**Solution**: Define custom managers to give meaningful names to common queries.
**解决方案**：通过定义自定义的管理器，使常见的查询拥有意义的名称。  

### 问题细节
Every Django model has a default manager called objects. Invoking objects.
all(), will return all the entries for that model in the database. Usually, we are
interested in only a subset of all entries.
每一个Django的模型都有一个默认称做`objects`的管理器。调用`objects.all()`会返回数据库中的这个模型的所有条目。通常，我们只对所有条目的子集感兴趣。

We apply various filters to find out the set of entries we need. The criterion to select
them is often our core business logic. For example, we can find the posts accessible
to the public by the following code:
我们应用多种过滤器以找出所需的条目组。挑选它们的原则常常是我们的核心业务逻辑。例如，我们发现使用下面的代码可以通过public访问文章：

```python
    public = Posts.objects.filter(privacy="public")
```

This criterion might change in the future. Say, we might want to also check
whether the post was marked for editing. This change might look like this:
这个标准在未来或许会改变。我们或许也想要检查文章是否标记为编辑。这个改变或许如此：  

```python
    public = Posts.objects.filter(privacy=POST_PRIVACY.Public, draft=Flase)
```

However, this change needs to be made everywhere a public post is needed.
This can get very frustrating. There needs to be only one place to define such
commonly used queries without 'repeating oneself'.
可是，这个改变需要使在任何地方都要用到公共文章。这令人非常沮丧。这仅需要一个定义这样常见地查询而无需“自我重复”。  

### 详解
QuerySets are an extremely powerful abstraction. They are lazily evaluated only
when needed. Hence, building longer QuerySets by method-chaining (a form of
fluent interface) does not affect the performance.
`Querysets`是一个功能极其强大的抽象概念。它们仅在需要时才进行惰性查询。因此，通过链式方法（一个顺畅的接口）构建长的`Querysets`并不影响性能。  

In fact, as more filtering is applied, the result dataset shrinks. This usually reduces
the memory consumption of the result.
事实上，随着更多的过滤的应用反倒会使结果数据集合得以缩减。这样做的话通常能够减少内存消耗。  

A model manager is a convenient interface for a model to get its QuerySet object.
In other words, they help you use Django's ORM to access the underlying database.
In fact, managers are implemented as very thin wrappers around a QuerySet object.
Notice the identical interface:
模型管理器是一个模型获取自身`Queryset`对象的便利接口。换句话来讲，它们有助于你使用Django的ORM访问下层的数据库。事实上，`QuerySet`对象上管理器以一个非常简单的包装器实现。请注意相同到接口：  

```python
    >>> Post.objects.filter(posted_by__username="a")
    [<Post:a: Hello World>， <Post:a: This is Private!>]

    >>> Post.objects.get_queryset().filter(posted_by__username="a")
    [<Post:a: Hello World>, <Post:a: This is Private!>]
```

The default manager created by Django, objects, has several methods, such as all,
filter, or exclude that return QuerySets. However, they only form a low-level
API to your database.
默认的管理器由Django创建，`objects`有多种方法返回`Queryset`，比如`all`，`filter`或者`exclude`。不过，它们仅仅是生成了一个到数据库的低级API。  

Custom managers are used to create a domain-specific, higher-level API. This is
not only more readable but less affected by implementation details. Thus, you
are able to work at a higher level of abstraction closely modeled to your domain.
定制管理器用于创建特定的域名，高级API。这样不仅更具可读性，而且通过实现细节减轻所受到的影响。因此，你就能够利用高级抽象来严格的对域名建模了。  

Our previous example for public posts can be easily converted into a custom
manager as follows:
如下，前面的公开文章例子就可以很轻松地转换为一个定制的管理器：  

```python
# managers.py
from django.db.models.query import Queryset


class PostQuerySet(QuerySet):
    def public_posts(self):
        return self.filter(privacy="public")

PostManager = PostQuerySet.as_manager
```

This convenient shortcut for creating a custom manager from a QuerySet object
appeared in Django 1.7. Unlike other previous approaches, this PostManager
object is chainable like the default objects manager.
这是一个在Django 1.7中从`QuerySet`对象创建定制管理器的捷径。不像前面的其他方法，这个`PostManager`对象像默认的`objects`管理器一样是可链式的。  

It sometimes makes sense to replace the default objects manager with our custom
manager, as shown in the following code:
如下所示，有些时候，使用定制的管理器替换去默认的`objects`管理器也是可行的：  

```python
from .managers import PostManager

class Post(Postable):
    ...
    objects = PostManager()
```

By doing this, to access public_posts our code gets considerably simplified to the
following:
这样，访问`public_posts`就相当简单了：  

```python
    public = Post.objects.public_posts()
```

Since the returned value is a QuerySet, they can be further filtered:
因为返回值是一个`QuerySet`，它们可以更进一步过滤：  

```python
    public_apology = Post.objects.public_posts().filter(
        message_startwith = "Sorry"
        )
```

QuerySets have several interesting properties. In the next few sections, we can take
a look at some common patterns that involve combining QuerySets.
`QuerySets`由多个值得注意的属性。在下一节里，我们可以看到一些含有混合`QuerySet`的常见地模式。  

### Querysets的组合动作  
True to their name (or the latter half of their name), QuerySets support a lot of
(mathematical) set operations. For the sake of illustration, consider two QuerySets
that contain the user objects:
事实上，对于它们的名字（或者是他们名字的后一半），`QuerySets`支持多组（数学上的）操作。为了说明，考虑包含用户对象的两个`QuerySets`：  

```python
    >>> q1 = User.objects.filter(username__in["a", "b", "c"])
    [<User:a>, <User:b>, <User:c>]
    >>> q2 = User.objects.filter(username__in["c", "d"])
    [<User:c>, <User:d>]
```

Some set operations that you can perform on them are as follows:
对于一些组合操作可以执行以下动作：  

*   *Union*: This combines and removes duplicates. Use q1 | q2 to get [<User:
a>, <User: b>, <User: c>, <User: d>]
*   *Union－交集*：合并，移除重复动作。使用`q1`|`q2`获得[`<User: a>, <User: b>, <User: c>, <User: d>`]  

*   *Intersection*: This finds common items. Use q1 and q2 to get [<User: c>]
*   *Intersection－并集*：找出公共项。使用`q1`|`q2`获得[`<User: c>]  

*   *Difference*: This removes elements in second set from first. There is no
logical operator for this. Instead use q1.exclude(pk__in=q2) to get [<User:
a>, <User: b>]
*   *Difference－补集*：从第一个集合中移除同时包含在第二个集合中的元素。该操作并不按逻辑来。改用`q1.exlude(pk__in=q2)获得［<User: a>, <User: b>］

The same operations can be done using the Q objects:
同样的操作我们也可以用`Q`对象来完成：

```python
from django.db.models import Q

# Union 交集
>>> User.objects.filter(Q(username__in["a", "b", "c"]) | Q(username__in=["c", "d"]))
[`<User: a>, <User: b>, <User: c>, <User: d>`]

# Intersection 并集
>>> User.objects.filter(Q(username__in["a", "b", "c"]) & Q(username__in=["c", "d"]))
[<User: c>]

# Difference 补集
>>> User.objects.filter(Q(username__in=["a", "b", "c"]) & ~Q(username__in=["c", "d"]))
[<User: a>, <User: b>]
```

Note that the difference is implemented using & (AND) and ~ (Negation).
The Q objects are very powerful and can be used to build very complex queries.
注意执行动作所使用`&`（和）以及`~`（否定）的不同。`Q`对象是非常强大的，它可以用来构建非常复杂的查询。  

However, the Set analogy is not perfect. QuerySets, unlike mathematical sets,
are ordered. So, they are closer to Python's list data structure in that respect.
不过，`Set`虽相似但却不完美。`QuerySets`不像数学上的集合那样按照顺序来。因此，就这方面来说它们更接近于Python的列表数据结构。  

### 链接多个Querysets  
So far, we have been combining QuerySets of the same type belonging to the same
base class. However, we might need to combine QuerySets from different models
and perform operations on them.
目前为止，我们已经合并了属于相同基类的同类型`QuerySets`。可是，我们或许需要合并来自不同模型的`QuestSets`，并对它们执行操作。  

For example, a user's activity timeline contains all their posts and comments in
reverse chronological order. The previous methods of combining QuerySets won't
work. A naïve solution would be to convert them to lists, concatenate, and sort them,
like this:
例如，一个用户的活动时间表包含了它们自身所有的按照反向时间顺序所发布的文章和评论。之前混合`QuerySets`方法是不会起作用的。一个很天真的做法是把它们转换到列表，连接并排列这个列表：  

```python
>>> recent = list(posts)+list(comments)
>>> sorted(recent, key=lambda e: e.modified, reverse=True)[:3]
[<Post: user: Post1>, <Comment: user: Comment1>, <Post: user: Post0>]
```
Unfortunately, this operation has evaluated the lazy QuerySets object. The
combined memory usage of the two lists can be overwhelming. Besides, it can be
quite slow to convert large QuerySets into lists.
不幸的是，这个操作已经对惰性的`QuerySets`对象求值了。两个列表的内存使用算在一起可能很大内存开销。另外，转换一个庞大的`QuerySets`到列表是很慢很慢的。  

A much better solution uses iterators to reduce the memory consumption. Use the
itertools.chain method to combine multiple QuerySets as follows:
一个更好的解决方案是使用迭代器减少内存消耗。如下，使用`itertools.chain`方法合并多个`QuerySets`：  

```python
>>> from itertools import chain
>>> recent = chain(posts, comments)
>>> sorted(recent, key=lambda e: e.modified, reverse=True)[:3]
```

Once you evaluate a QuerySet, the cost of hitting the database can be quite high.
So, it is important to delay it as long as possible by performing only operations that
will return QuerySets unevaluated.
只要计算`QuerySets`，连接数据的开销都会非常搞。因此，重要的是，尽可能长的仅有的不对`QuerySets`求值的操作时间。  

>##提示
Keep QuerySets unevaluated as long as possible.
尽量延长`QuerySets`不求值的时间。  

## 迁移
Migrations help you to confidently make changes to your models. Introduced in
Django 1.7, migrations are an essential and easy-to-use parts of a development
workflow.
迁移让你改变模型时更有信心。说的Django 1.7，迁移已经是开发流程中基本的易于使用的一部分了。  

The new workflow is essentially as follows:
新的基本流程如下：

1. The first time you define your model classes, you will need to run:
python manage.py makemigrations <app_label>
1. 第一次定义模型类的话，你需要运行：  
python manage.py makemigrations <app_label>

2. This will create migration scripts in app/migrations folder.
2. 这将在`app/migrations/`文件夹内创建迁移脚本。  
在同样的（开发）环境中运行以下命令：  
python manage.py migrate <app_label>

3. Run the following command in the same (development) environment:
python manage.py migrate <app_label>
This will apply the model changes to the database. Sometimes, questions
are asked to handle the default values, renaming, and so on.
3. 这将对数据库应用模型变更。有时候，遇到的问题有，处理默认值，重命名，等等。  

4. Propagate the migration scripts to other environments. Typically, your
version control tool, for example Git, will take care of this. As the latest
source is checked out, the new migration scripts will also appear.
4. 普及迁移脚本到其他的环境。通常，你的版本控制工具，例如，Git，会小心处理这事。当最新的源释出时，新的迁移脚本也会随之出现。  

5. Run the following command in these environments to apply the
model changes:
5. 在这些环境中运行下面的命令以应用模型的改变：  
python manage.py migarte <app_label>

6. Whenever you make changes to the models classes, repeat steps 1-5.
6. 不论何时要将变更应用到模型，请重复以上1-5步骤。

If you omit the app label in the commands, Django will find unapplied changes
in every app and migrate them.
如果你在命令里忽略了app标签，Django会在每一个app中发现未应用的变更并迁移它们。  


## 总结
Model design is hard to get it right. Yet, it is fundamental to Django development.
In this chapter, we looked at several common patterns when working with models.
In each case, we looked at the impact of the proposed solution and various tradeoffs.
模型设计要正确地操作很困难。它依然是Django开发的基础。本章，我们学习了使用模型时多个常见模式。每个例子中，我们都见到了建议方案的作用，以及多种折衷方案。  

In the next chapter, we will examine the common design patterns we encounter
when working with views and URL configurations.
这下一章，我们会用视图和URL配置来验证所遇到的常见设计模式。
